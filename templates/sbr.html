<!-- templates/sbr.html -->
{% extends 'base.html' %}

{% block title %}SBR Configuratie & Status{% endblock %}

{% block head %}
<style>
  section.sbr-config {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    width: 100%;
  }
  .sbr-phase-list {
    width: 100%;
    max-width: 500px;
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  .phase-box {
    display: grid;
    grid-template-columns: 1fr auto auto auto;
    align-items: center;
    background: #f9f9f9;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    font-size: 1rem;
    gap: 0.5rem;
    transition: background 0.3s;
  }
  .phase-box.active { background: #28a745; color: #fff; }
  section.sbr-config.paused .phase-box.active {
    background: #ffc107;
    color: #333;
  }
  .phase-name { font-weight: bold; }
  .phase-progress { text-align: right; min-width: 8rem; }
  .phase-elapsed-container.hidden { visibility: hidden; }
  .phase-input {
    width: 4rem;
    padding: 0.3rem;
    font-size: 0.9rem;
    border: 1px solid #ccc;
    border-radius: 0.25rem;
  }
  .phase-set-btn {
    padding: 0.8rem 1rem;
    font-size: 0.9rem;
    border: none;
    border-radius: 0.25rem;
    background: #007bff;
    color: #fff;
    cursor: pointer;
  }
  .phase-set-btn:hover { background: #0056b3; }
</style>
{% endblock %}

{% block content %}
<section class="sbr-config" id="sbr-config-section">
  <h1>SBR Configuratie & Status</h1>
  <div style="margin-top:0;">
    <button id="btn-toggle" class="phase-set-btn">Start Cycle</button>
    <button id="btn-reset"  class="phase-set-btn">Reset Cycle</button>
  </div>
  <div class="sbr-phase-list">
    {% for key,label in [('influent','Influent'),('react','React'),('effluent','Effluent'),('wait','Wait')] %}
    <div class="phase-box" id="phase-{{ key }}-box">
      <div class="phase-name">{{ label }}</div>
      <div class="phase-progress">
        <span class="phase-elapsed-container hidden" id="{{ key }}-elapsed-container">
          <span class="phase-elapsed" id="{{ key }}-elapsed"></span> /
        </span>
        <span class="phase-total" id="{{ key }}-total"></span> s
      </div>
      <input type="number" step="0.1" min="0.1"
             class="phase-input" id="{{ key }}-input" placeholder="min">
      <button class="phase-set-btn" data-phase="{{ key }}">Set</button>
    </div>
    {% endfor %}
  </div>
</section>
{% endblock %}

{% block scripts %}
<script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.min.js"></script>
<script>
  // Automatisch verbinden en handlers registreren
  const socket = io('/sbr');
  const phases = ['influent','react','effluent','wait'];
  const boxes = {}, elapsCont = {}, elapsedElems = {}, totalElems = {}, inputElems = {}, setBtns = {};

  // Element-referenties en events
  phases.forEach(p => {
    boxes[p] = document.getElementById(`phase-${p}-box`);
    elapsCont[p] = document.getElementById(`${p}-elapsed-container`);
    elapsedElems[p] = document.getElementById(`${p}-elapsed`);
    totalElems[p] = document.getElementById(`${p}-total`);
    inputElems[p] = document.getElementById(`${p}-input`);
    setBtns[p] = document.querySelector(`.phase-set-btn[data-phase="${p}"]`);

    setBtns[p].addEventListener('click', () => {
      const val = parseFloat(inputElems[p].value);
      if (isNaN(val) || val <= 0) return alert(`Tijd voor ${p} moet groter zijn dan 0`);
      socket.emit('sbr_set_phase_times', { [p]: val });
    });
    inputElems[p].addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); setBtns[p].click(); }
    });
  });

  document.getElementById('btn-toggle').addEventListener('click', () =>
    socket.emit('sbr_control', { action: 'toggle' })
  );
  document.getElementById('btn-reset').addEventListener('click', () =>
    socket.emit('sbr_control', { action: 'reset' })
  );

  // Bij connect: vraag instellingen opnieuw op
  socket.on('connect', () => {
    socket.emit('sbr_get_phase_times');
  });

  // Ontvang instellingsdata
  socket.on('sbr_phase_times', data => {
    phases.forEach(p => {
      elapsCont[p].classList.add('hidden');
      totalElems[p].textContent = data[p + '_seconds'];
      inputElems[p].value = data[p + '_minutes'];
    });
  });

  // Status (start/pauze)
  socket.on('sbr_status', data => {
    document.getElementById('btn-toggle').textContent = data.active ? 'Stop Cycle' : 'Start Cycle';
    document.getElementById('sbr-config-section').classList.toggle('paused', !data.active);
  });

  // Timerupdates
  socket.on('sbr_timer', data => {
    const { phase, phase_elapsed } = data;
    if (!phases.includes(phase)) return;
    phases.forEach(p => elapsCont[p].classList.add('hidden'));
    elapsedElems[phase].textContent = phase_elapsed;
    elapsCont[phase].classList.remove('hidden');
    phases.forEach(p => boxes[p].classList.toggle('active', p === phase));
  });
</script>
{% endblock %}
