<!-- templates/sbr.html -->
{% extends 'base.html' %}

{% block title %}SBR Configuratie & Status{% endblock %}

{% block head %}
<style>
  section.sbr-config {
    display: flex; flex-direction: column; align-items: center;
    padding: 1rem; width: 100%;
  }
  .sbr-phase-list {
    width: 100%; max-width: 700px; margin-top: 1rem;
    display: flex; flex-direction: column; gap: 0.75rem;
  }
  .phase-box {
    display: grid;
    grid-template-columns:
      2fr /* Naam */
      1fr /* Criterium */
      1fr /* Actueel */
      1fr /* Doel */
      2fr /* Invoer + knop */;
    align-items: center;
    background: #f9f9f9;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    gap: 0.5rem;
    transition: background 0.3s;
  }
  .phase-box.active { background: #28a745; color: #fff; }
  section.sbr-config.paused .phase-box.active {
    background: #ffc107; color: #333;
  }
  .phase-name { font-weight: bold; }
  .phase-criterion,
  .phase-actual,
  .phase-target { text-align: center; }
  .phase-input {
    width: 4rem; padding: 0.3rem; margin-right: 0.5rem;
    border: 1px solid #ccc; border-radius: 0.25rem;
  }
  .phase-set-btn {
    padding: 0.6rem 1rem; border: none; border-radius: 0.25rem;
    background: #007bff; color: #fff; cursor: pointer;
  }
  .phase-set-btn:hover { background: #0056b3; }
</style>
{% endblock %}

{% block content %}
<section class="sbr-config" id="sbr-config-section">
  <h1>SBR Configuratie & Status</h1>

  <div id="cycle-timer" style="font-size:1.2rem; margin-bottom:0.5rem;">
    Cyclus: 00:00
  </div>
  <div style="margin-bottom:1rem;">
    <button id="btn-toggle" class="phase-set-btn">Start Cycle</button>
    <button id="btn-reset"  class="phase-set-btn">Reset Cycle</button>
  </div>

  <div class="sbr-phase-list">
    {% for key,label in [
         ('influent','Influent'),
         ('react','React'),
         ('effluent','Effluent'),
         ('wait','Wait')
       ] %}
    <div class="phase-box" id="phase-{{ key }}-box">
      <div class="phase-name">{{ label }}</div>
      <div class="phase-criterion">
        {{ 'Level' if key=='influent' else 'Time' }}
      </div>
      <div class="phase-actual" id="{{ key }}-actual">--</div>
      <div class="phase-target" id="{{ key }}-target">--</div>
      <div>
        <input
          type="number" step="0.1" min="0"
          class="phase-input"
          id="{{ key }}-input"
          placeholder="{% if key=='influent' %}Set level{% else %}min{% endif %}"
        >
        <button class="phase-set-btn" id="btn-set-{{ key }}">Set</button>
      </div>
    </div>
    {% endfor %}
  </div>
</section>
{% endblock %}

{% block scripts %}
<script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.min.js"></script>
<script>
  const sbrSocket    = io('/sbr');
  const sensorSocket = io('/sensors');
  const phases       = ['influent','react','effluent','wait'];

  const cycleTimer = document.getElementById('cycle-timer');
  const btnToggle  = document.getElementById('btn-toggle');
  const btnReset   = document.getElementById('btn-reset');

  // caches voor DOM-elementen
  const boxes  = {}, actual = {}, target = {}, inputs = {}, btns = {};

  // houd laatste phase bij om highlight te behouden
  let lastPhase = 'influent';

  // helper om highlight in te stellen
  function updateHighlight(phase) {
    phases.forEach(p => {
      boxes[p].classList.toggle('active', p === phase);
    });
  }

  // init references en click-handlers
  phases.forEach(p => {
    boxes[p]  = document.getElementById(`phase-${p}-box`);
    actual[p] = document.getElementById(`${p}-actual`);
    target[p] = document.getElementById(`${p}-target`);
    inputs[p] = document.getElementById(`${p}-input`);
    btns[p]   = document.getElementById(`btn-set-${p}`);
    btns[p].addEventListener('click', () => {
      const v = inputs[p].valueAsNumber;
      if (isNaN(v) || v < 0) {
        return alert((p === 'influent' ? 'Level' : 'Time') + ' must be â‰¥ 0');
      }
      if (p === 'influent') {
        sbrSocket.emit('sbr_set_threshold', { threshold: v });
      } else {
        sbrSocket.emit('sbr_set_phase_times', { [p]: v });
      }
    });
  });

  btnToggle.addEventListener('click', () =>
    sbrSocket.emit('sbr_control', { action: 'toggle' })
  );
  btnReset.addEventListener('click', () =>
    sbrSocket.emit('sbr_control', { action: 'reset' })
  );

  // bij connect, vraag setpoints en threshold
  sbrSocket.on('connect', () => {
    sbrSocket.emit('sbr_get_phase_times');
  });

  // ontvangst setpoints & threshold
  sbrSocket.on('sbr_phase_times', data => {
    target['influent'].textContent = data.influent_threshold;
    inputs['influent'].value       = data.influent_threshold;
    ['react','effluent','wait'].forEach(p => {
      inputs[p].value       = data[`${p}_minutes`];
      target[p].textContent = data[`${p}_seconds`];
    });
  });

  // Start/Stop status: update knop en behoud highlight
  sbrSocket.on('sbr_status', data => {
    btnToggle.textContent = data.active ? 'Stop Cycle' : 'Start Cycle';
    document.getElementById('sbr-config-section')
      .classList.toggle('paused', !data.active);
    // herhaal laatste highlight, ook bij Stop
    updateHighlight(lastPhase);
  });

  // Live timer & phase: update timer, actual (voor tijd-fases en niveau), target en highlight
  sbrSocket.on('sbr_timer', data => {
    // globale timer
    const m = String(Math.floor(data.timer / 60)).padStart(2,'0'),
          s = String(data.timer % 60).padStart(2,'0');
    cycleTimer.textContent = `Cyclus: ${m}:${s}`;

    // update lastPhase en highlight
    lastPhase = data.phase;
    updateHighlight(data.phase);

    // actual voor tijd (fase_elapsed) en voor influent (from actual_level)
    phases.forEach(p => {
      if (p === 'influent') {
        if (data.actual_level != null) {
          actual[p].textContent = data.actual_level.toFixed(2);
        }
      } else {
        actual[p].textContent = (p === data.phase)
          ? data.phase_elapsed
          : '0';
      }
    });

    // altijd target (setpoint) tonen
    if (data.phase_target !== undefined) {
      target[data.phase].textContent = data.phase_target;
    }
  });

  // Continu actual level bijwerken via sensor_updates
  sensorSocket.on('sensor_update', readings => {
    const lvl = readings.find(r => r.slave_id === 5 && r.channel === 0);
    if (lvl) {
      actual['influent'].textContent = lvl.value.toFixed(2);
    }
  });
</script>
{% endblock %}
